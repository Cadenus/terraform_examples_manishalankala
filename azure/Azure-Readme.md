
**Azure Firewall** provides inbound protection for non-HTTP/S protocols (for example, RDP, SSH, FTP), outbound network-level protection for all ports and protocols, and application-level protection for outbound HTTP/S.

**Azure Firewall** alone when there are no web applications in the virtual network.

**Application Gateway** alone when there are only web applications in the virtual network, and network security groups (NSGs) provide sufficient output filtering.

**Azure Firewall and Application Gateway** in parallel, the most common design, when you want Azure Application Gateway to protect HTTP(S) applications from web attacks, and Azure Firewall to protect all other workloads and filter outbound traffic.

**Application Gateway** in front of Azure Firewall when you want Azure Firewall to inspect all traffic and WAF to protect web traffic, and the application needs to know the client's source IP address.

**Azure Firewall** in front of Application Gateway when you want Azure Firewall to inspect and filter traffic before it reaches the Application Gateway.









1.**USE MODULES TO AVOID REPETITIVE WORK**

Modules in Terraform allow you to reuse predefined resource structures. 
Using modules will decrease the snowflake effect and provide a great way to reuse existing infrastructure code.
Modules have some variables as inputs, which are located in different places (eg. A different folder, or even a different repository). 
They define elements from a provider and can define multiple resources in themselves.
Modules are called using the module block in our Terraform configuration file, variables are defined according to the desired requirement.



we can use tags or branches names or in repo for source

```
	module "my-db-module" {
		source = "git::ssh://git@mygitserver.com/my-modules.git//modules/my_module?ref=feature-branch-001"
		allocated_storage = "200"
		instance_class = "db.t2.micro"
		engine = "postgres"

```


2. **MANAGE TERRAFORM STATE**

The Terraform state file is important for Terraform because all the current states of our Infrastructure are stored here. 
It's a .json file normally located in the hidden folder .terraform inside your Terraform configuration files (.terraform/terraform.tfstate) and is autogenerated when you execute the command terraform apply.

As we work on our infrastructure, other collaborators might need to modify the infrastructure and apply their changes, changing the Terraform state file, which is why we recommend that this file be stored in a shared storage. 
Terraform supports multiple Backends to store this file, like etcd, azurem, S3 or Consul.

as Infrastructure grows and you need to define multiple environments, you might need to split your Terraform state by environments and by components inside each environment. This way you will be able to work on different environments at the same time and multiple collaborators could work on different components of the same Infrastructure without being locked


```
# my_infra/prod/database/main.tf:
		...
		key			= "prod/database/terraform.tfstate"
		...
# my_infra/dev/database/main.tf:
		...
		key			= "dev/database/terraform.tfstate"
		...
# my_infra/dev/loadbalancer/main.tf:
		...
		key			= "dev/loadbalancer/terraform.tfstate"


```		
		
3.DEFINING OUTPUTS		

Outputs show the information needed after Terraform templates are deployed. They are also used within modules to export information.



PAC : Pipeline as Code

Azure Artifacts :
```
Azure Artifacts is a package management solution
Azure Artifacts enables developers to share and consume packages from different feeds and
Packages can be shared within the same team, the same organization, and even publicly
Through Azure Devops integration we can create and share Maven, NPM, NuGet Packages 


Benefits:
Keep your artifacts organised:
Share code effortlessly by storing Maven, npm, NuGet and Python packages together.
Protect your packages:
Keep every public source package you use-including packages from npmjs and nuget.org-safe
Integrate seamless package handling into your CI/CD pipeline
Easily access all your artifacts in builds and releases-Artifacts integrates native

```

Integrate seamless package handling into your CI/CD pipeline
Easily access all your artifacts in builds and releases-Artifacts integrates natively with

Steps:
- Icreation of a package feed : 1.Create a team feed 2.Connect to the feed in Azure DevOps

- Build Integration : 1.Pack and Push packages to your feed 2.Setting up Visual studio to consume the feed

- Consume from a feed : 1.Running build and restoring packages from team feed 2.Setting up new solution locally to consume feed



$ (system.defaultworkingdirectory)'
The local path on the agent where your source code


'$ (build.artifactstagingdirectory)'
The local path on the agent where any artifacts are copied
